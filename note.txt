1. exp15
- model: centernet tự code - backbone hourglass-104
- dữ liệu: full train + val
- loss: om loss + focal loss
- train được đến epoch 10 tự nhiên loss lăn đùng ra dương vô cùng, bị stop training
- lr scheduler: 0.01 cho 20 epoch đầu, sau đó giảm xuống 0.001, nhưng chưa qua 20 ep đầu đã bị kill

Kết quả: cho predict trên tập test khá tốt

2. exp14
- model: mycenternet
- dữ liệu: limit 500 sample train
- Kết quả: fit được và dự đoán tốt trên tập train

3. exp13
- model: smpunet
- lr: 0.1 lúc đầu, sau giảm đi
- có hội tụ được

4. exp22:
- model: smpunet++ + resnet34 backbone
- dữ liệu: full
- lr: 0.001, AdamW, no scheduler
- đang hội tụ được


----------------------- 17-05-2023 ------------------------
1. Thêm augment mask ball để tránh false positive

2. Chạy infer thử với mấy model train được
    2.1 unet++_effb0, fp16, 3 frames
    - test acc: 0.991

    2.2 centernet_yolo_3_frames, fp16:
    - test acc: 0.994
    - cao hơn nhưng có khi là do train nhiều epoch hơn

    2.3 unet++_resnet34, fp32, 5 frames
    - test_acc: 0.994

3. Dữ liệu test của họ là khoảng 7400 frames
- Mình chỉ có khoảng 5400 frames
- Tuy nhiên check hết những frame mà ball được annotate cũng chỉ có khoảng 6400 frames
=> Sau này nếu cần sẽ lấy ra thêm frame từ để cho vào test

- Lý do thiếu là bởi tất cả frame extract ra đều là những frame gần với event bounce hoặc net
=> sẽ không có những frame mà bóng ở xa bàn nên nó sẽ ko detect được 

4. Kịch bản training
- Train với 5 frame liên tiếp
- Các model thử nghiệm
  + SmpDeepLabV3Plus + backbone efficientnet-b0
  + centernet_yolo + backbone yolo8n
  + CenternetHourGlass
- Các thông số cần quan tâm khác
 + optimizer: AdamW, lr = 0.001, scheduler = ReduceLROnPlateau, factor=0.2, patience=5
 + precision: 16
 + mask_ball_prob: 0.2, để tránh false positive
 + ball_radius on 512x512: (7, 7)


----------------------- 19-05-2023 ------------------------
1. tìm ra conf_threshold:
- các predict thường có score lớn hơn 0.6
- trong 10 batch đầu (320 ảnh), mean score = 0.84, med = 0.84
=> để tránh false positive nên chọn conf_thresh = 0.5

2. So sánh kết quả các kịch bản thử nghiệm trên tập test
- centernet_v8n_fixed_mask_ball: exp38, epoch 18, test acc: 0.996, mean_rmse: 1.664 (on 512 x 512 image)
- centernet_v8n chưa fix mask ball: exp28, epoch 14, test acc: 0.993
- smpdeeplabv3+_effb0 chưa fix mask ball: epoch 18, test acc: 0.991
=> centernet_v8n tốt hơn
=> fixed mask ball tốt hơn hẳn chưa fix

3. Thay đổi hàm decode_hm bằng cách chỉ việc lấy activation max nhất trên heatmap, khỏi cần kernel 3x3 làm gì
- vì chỉ có 1 đối tượng duy nhất trong ảnh

4. Tại sao lại chọn cách heatmap này ? Tại sao ko dùng luôn mấy anchor-free detector như yolov8 luôn
- hỏi a Sơn ý tưởng của yolov8
- hỏi về cái ASFF module
- hỏi tại sao deploy mô hình to lại ko được
- Đóng góp trong việc detect bóng nhỏ
  + vì sao chọn cách heatmap ?
  + kĩ thuật gì giúp detect bóng nhỏ tốt hơn
    + weight class bóng lên, chỗ nào pixel là bóng mà pred là 0 thì phạt nặng hơn
    + augment paste bóng, lưu ý cần phải đúng thứ tự
    + tại sao dùng nhiều frame: vì bóng hay bị mờ, nếu chỉ để 1 frame thì bóng sẽ là 1 vệt trắng trắng dài dài, và nhiều khi tự nhiên cũng có 1 vệt trắng trắng dài dài
    => thế là bị dễ nhầm thành bóng => hỏng

5. train tiếp centernet_yolov8s xem có tốt hơn yolov8n không ?
- NOT DONE

6. viết code để train được mạng có cả event_spotting

7. 1 image 512x512x3 chiếm 0.75mb trong RAM
=> 5gb ram có thể cache được khoảng 7-800 samples, mỗi sample là 9 ảnh

8. Tập dữ liệu
8.1: 9 frames
train: 21261
val: 3752
test: 3743


------------------- 20-05-2023 -----------------------------
1. smp unet bị lỗi vô lý
- focaloss = inf
- l1_loss = 0
- Mà dùng effunet mình tự code thì lại chạy bth, hội tụ cũng khá nhanh, 1 nửa epoch đầu mà acc đã được tầm 50%
- Nguyên nhân:
  + Head đang quên dùng activation, vẫn để act mặc định là Linear:), dẫn đến loss = inf ngay
  => Hàm act ảnh hưởng nhiều thật

  + Do ko có head hoặc head đang dùng quá dài => lấy head vừa vừa chỉ bao gồm 2 lớp Conv, ko có batchnorm
    + Head cũ đang dùng:
          # ConvBlock(in_c=c, out_c=c*4, act=nn.SiLU()),
          # ConvBlock(in_c=c*4, out_c=c*4, act=nn.SiLU()),
          # ConvBlock(in_c=c*4, out_c=c, act=nn.SiLU()),

          # nn.Conv2d(c, c*4, kernel_size=3, stride=1, padding=1),
          # nn.SiLU(),
          # nn.Conv2d(c*4, c*4, kernel_size=3, stride=1, padding=1),
          # nn.SiLU(),
          nn.Conv2d(c, c, kernel_size=3, stride=1, padding=1),
          nn.SiLU(),

          nn.Conv2d(c, 1, kernel_size=1, stride=1, padding=0),
          nn.Sigmoid()
    + Trong khi head chuẩn chỉ bao gồm 4 dòng cuối ko có comment thôi, head dài quá có khi cũng ko tốt
    + Head dài quá chắc chắn ko tốt, vì dùng cùng 1 mạng EffUnet với head nhỏ thì hội tụ rất nhanh, trong khi với head to thì lại như shit
    
  + Encoder dùng SilU, mà decoder lại dùng relu => hội tụ cũng chậm hơn
    + Code mặc định của SmpUnet với backbone EfficientnetB0 đang bị vậy. Decoder của unet++ luôn dùng hàm act là ReLU
    + Lỗi này đã được chứng minh: Chạy SmpUnet thì loss = inf, trong khi chạy EffUnet với kiến trúc y hệt (chỉ thêm 2 lớp head) 
      thì kết quả tốt hơn hẳn

- Cách khắc phục: Dùng SmpEffUnet
  + phần backbone là eff_b0 lấy từ torch vision
  + phần decoder là unet++ decoder lấy từ smp, đã đổi hàm act thành SiLU (decoder này đã có attentionUnet)
  + phần head chỉ bao gồm 2 lớp Conv như trên, ko có batchnorm
  + Đang đạt acc 0.997 trên tập valid

2. Speed up training
- Lightning tự động đưa tất cả những thứ trả về từ data loader (kể cả out_pos, norm_pos, hm_true, ...) sang gpu (nếu có gpu) ngay trong hàm common_step
- có 2 tips chính:
 + tạo tensor ngay trên cuda
 + ko dùng .item(), .cpu(), ... để tránh chuyển qua lại giữa cpu và gpu
 + tune num worker
 + set pin_memory = True trong DataLoader
 + dùng precision 16


-------------------------- 20-05-2023 -----------------------------
1. test effsmpunet với head nhỏ xịn trên tập test
- acc: 0.995, mean rmse: 1.801
- kết quả vẫn kém hơn centernet_yolov8n

2. Chốt model detect bóng riêng
- input 5 frames
- centernet_v8n_fixed_mask_ball: exp38, epoch 18, test acc: 0.996, mean_rmse: 1.664 (on 512 x 512 image)
- exp46_effsmpunet_silu_all_head_nho: acc: 0.995, mean rmse: 1.801


-------------------------- 23-05-2023 -----------------------------
1. test model centernet_event:

- trong trường hợp có nhãn là bounce và net là 1 hẳn, thì kết quả dự đoán thấy khá đúng
  + prob của class true ko cao lắm, chỉ tầm 0.5, 0.6 gì đó với class bounce, và 0.7, 0.8 với class net (DO CLASS NET CÓ WEIGHT LỚN HƠN KHI TÍNH HÀM LOSS)
  + prob của class còn lại luôn rất thấp, < 0.01 , WHICH IS GOOD
  + bounce = 1, mean_bounce_prob:
  + net = 1, mean_pred_prob:

- trường hợp có nhãn là bounce và net gần gần 1, quan sát cũng khá tương tự bên trên
  + tuy nhiên đã thấy 1 vài trường hợp dự đoán sai (prob của class đúng < prob của class sai)
  + prob của class sai vẫn nhỏ (< 0.05)
  + prob của class đúng ko đồng đều lắm (prob trong nhãn tăng nhưng chưa chắc prob trong pred đã tăng)
  + CLASS NET vẫn có điểm số tốt hơn (prob pred gần với prob true hơn)

- trường hợp empty event: đéo ổn rồi
  + prob pred vẫn cao rơi vào 1 trong 2 class, dù prob true là 0, 0 hết

- KẾT LUẬN:
  + class net tốt hơn class bounce rõ
  + đối với nhãn có sự kiện, dự đoán vẫn đúng 1 cách rõ ràng
    + prob của class wrong gần như luôn = 0
    + prob của class true tuy ko cao lắm nhưng cũng khoảng 0.5
  + tuy nhiên với nhãn ko có sự kiện, thì dự đoán sai bét nhè
    + prob pred vẫn cao rơi vào 1 trong 2 class, dù prob true là 0, 0 hết
  
  => Nếu chỉ cần dự đoán class bounce có vẻ là cũng oke đó

- So sánh với TTNet
  + Họ train local ball detection và event spot trong phase 2 với loss 1:2 (event spot có weight gấp đôi)
  + basr_lr = 0.001, giảm đi 10 lần sau mỗi 10 epochs
  + loss khác, lấy loss của nó xem sao

2. model event_cls kết quả có vẻ còn tệ hơn mô hình centernet_event
- prob pred của class true nhỏ hơn và prob pred của class wrong lại lớn hơn

3. Hướng thử nghiệm cuối cùng
3.1 Chỉ detect class bounce
- chỉnh lại kiến trúc mô hình:
- chỉnh lại data loader
- copy weight từ phần detect ball sang model mới
- train theo chiến lược của ttnet


-------------------------------- 24-5-2023 -----------------------------
1. phát hiện ra phần neck của centernet yolo dùng activation relu, trong khi cả mạng đều dùng silu
- tuy nhiên chưa sửa lại

2. phát hiện ra phần head event spot thiếu activation, sửa lại và đang train lại


3. Báo cáo thầy
- đã thử nghiệm 2 mạng 
  + input 5 frames
  + unet++ với effb0 encoder, test acc: 0.995
  + centernet yolov8n, test acc: 0.996
  + ttnet: 0.982

- augment:
  + mask ball
  + flip, rotate, shift scale ...
  
- khó khăn:
  + thử nghiệm hàm loss
    + bce
    + weighted bce
    + weighted bce + focal loss
    + ko weight class bóng lên vì mục đích là ko để false positive
  
- có time thì thử nghiệm thêm yolov8n
- đang thử nghiệm thêm cả event spotting vào trong mạng detect bóng
  + phân biệt class boucne và net khá oke trong trường hợp có 1 trong 2 class
  + tuy nhiên trường hợp nhãn empty cũng dự đoán vào 1 trong 2 => ko ổn
  => quyết định chỉ train phát hiện bounce
  + sửa lại 1 số bug: hàm activation dùng relu thay vì silu, head quá to


4. yolov8n -, mixed precision
result on test set:
- input size 512
true:  3034
total:  5404
acc:  0.561
mean rmse:  1.096

- input size 640
true:  4282
total:  5404
acc:  0.792
mean rmse:  1.665

- input size 1280
true:  5368
total:  5404
acc:  0.993
mean rmse:  0.684

-------------------------------------- 31-05-2023 ----------------------------------------
1. centernet_v8n_event
- exp65 on 156
- ev_true: 3575, ev_total: 3743, ev_acc: 0.955,
- Đây là độ chính xác event, tính theo threshold 0.25
- tính lại độ chính xác ball và event xem sao\


 + do chinh xac event
   + total_0_1: 2326
   + tp: 231
   + fp: 5
   + tn: 2088
   + fn: 2


 + do chinh xac bong: (9 frame lien tiep)
   + true: 3723
   + total: 3743
   + acc: 0.995
   => đây là trong tập tất cả đều có bóng
   
 + do chinh xac trong tập đã mask hết bóng
  true:  3726
  total:  3743
  acc:  0.995
  => nhận nhầm vị trí bóng của 17 frames, từ ko có bóng thành có bóng hoặc nhận sai vị trí

2. báo cáo
- làm 2 việc chính: 
+ train centernet_event 
+ so sánh kết quả với yolov8n
- thử nghiệm 1 mô hình detect sự kiện riêng
 + 1 luồng là cnn, chuỗi các ảnh đã cắt vùng xung quanh bóng
 + 1 luồng là lstm, đầu vào là chuỗi các vị trí bóng
- hỏi thầy
 + deploy kiểu gì thì tốt: web ? docker ?
 + có cần làm thêm mô hình gì nữa ko (liệu khối lượng công việc như này đã oke chưa)
 + 